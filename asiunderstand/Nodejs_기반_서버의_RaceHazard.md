# Node.js 기반 서버의 Race hazard

## Node.js는 싱글스레드다?

--- 

흔히들 Node.js는 싱글스레드라 말하지만, 엄밀히 따지면 Node.js 자체는 싱글스레드가 아니다. 정확히 말하면 자바스크립트를 한줄씩 읽어 수행하는 메인스레드인 이벤트 루프가 싱글 스레드일 뿐이다. 즉,

> "Node 런타임에서 구동되는 자바스크립트 코드는 싱글 스레드인 이벤트 루프에 의해서 수행된다."

가 더 올바른 표현일 것이다.

자바스크립트 코드에서 사용한 Node.js API들이 CPU연산과 논리를 수행하는 작업일 경우, 여타 언어들 처럼 LIFO를 충실히 따르면서 V8 엔진의 콜스택에 Push되었다가 Pop되며 수행된다. 하지만, I/O bound(disk, network 에 대한 접근)등의 **비동기 작업에 도달하면 Node.js API는 libuv라는 라이브러리를 호출한뒤 기다리지 않고 콜스택을 Pop 시키며 다음 줄이 실행된다.**

libuv는 OS 시스템의 비동기 처리를 한단계 추상화 하여 cross-platform 비동기를 구현한 라이브러리로 이벤트 루프를 포함한다([https://github.com/libuv/libuv/tree/v1.x/src/unix](https://github.com/libuv/libuv/tree/v1.x/src/unix)). Node.js 의 비동기 API libuv를 호출하면 Block 상태에 있던 이벤트 루프가 실행되는데, **이벤트 루프는 비동기 작업의 종류에 따라서 libuv 스스로의 스레드 풀(Defualt 4개의 스레드) 혹은 커널의 비동기 API를 이용하여 작업을 수행한 뒤, 이벤트 큐 쌓인 콜백이 있는지를 검사하여 수행하기를 반복한다.** libuv의 각 스레드는 맡은 작업을 모두 수행하면 작업의 종류에 따라서 콜백함수를 이벤트 큐에 삽입함으로써 추후 이벤트 루프에 의해 수행 될 것을 기대한다

비교하자면, Java 로 짜여진 웹 서버는 요청당 하나의 스레드를 만든다.
Node.js 는 모든 요청을 단일 스레드로 받는다. 다른 멀티스레딩 방식의 서버

## RaceHazard 가 발생하는 경우

--- 

여러개의 요청이 공유하는 리소스에 접근할 때 특히 주의를 기울여야한다. 모든 요청이 해당 리소스에 대해서 읽기만 수행하면 괜찮지만, 

## 해결방법

---

### 1. Transaction Isolation Level
### 2. Messaging Queue 의 사용
