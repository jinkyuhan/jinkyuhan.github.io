---
layout: post
title: NodeJS는 싱글스레드다?
date: 2020-08-24
summary: 아니 노드는 싱글스레드잖아, 그러면 비동기API는 누가 처리하는거야?
categories: study
---

## 내가 이걸 왜 생각하게 됐지를 먼저 생각해 봄

<br>
학부 졸업 후 바로 노드를 이용해서 실무에 나서게 되면서,
노드는 **싱글스레드 기반**이라는 사실을 그냥 의심없이 받아들였던 것 같다.<br>

왜냐면 부끄럽지만 내가 봤던 많던 많은 입문용 블로그, 서적들에 그렇게 막연히 적혀있었거든..

그런데 이 노드라는 친구와 익숙해지고 나서, 이 친구에게는 나의 짧은 콤퓨타쟁이 지식으로는 납득할 수 없는 행동양식이 있다는 것을 발견했다.

~~그럼에도 실무에 쫒겨 깊은 탐구를 미뤄왔다. 미안해 미래의 나~~

그래서 이번기회에, 당장은 프로덕트의 구현과 실무가 우선이라 생각해서 ~~(게을렀던건 아닐까?)~~ 미뤄놓았던 의문점에 대해 납득할만한 결론을 내려보기로 했다.

---

## 바로 본론으로 ㄱㄱ

<br>
(어리석은 내가 이해하지 못하는) 똑똑한 노드의 별난 행동양식을 설명하기 위해 코드를 끄적여보자면...

```javascript
const fs = require('fs');

fs.writeFile('text.txt', 'text', () => {
  // callback
});
while (true) {
  // 무한루프. thread busy
  console.log('busy', 1 + 1);
}
```

이런상황에서, Node런타임의 시스템 프로세스는 CPU Bound의 작업을 하느라 매우 바쁜 상황일텐데.<br>
무한루프가 실행되는 와중에, 콜백은 실행되지 않지만(이까진 ㅇㅋ 이해됨)... **text라는 내용의 파일이 생긴다?!?**<br>

> **'왜? 싱글스레드라며? 싱글스레드에서 이런 여러가지 일을 문자 그대로 물리적으로 동시에하는 병렬성이 가능해?'**

노드 런타임도 OS 커널 위에 돌아가는 프로세스이니까... 노드의 어떤 부분이 어떤 복잡한 로직을 거쳐서 OS의 파일시스템 API를 호출하도록 구현되어 있을텐데...?

> **'그럼 도대체 어떤 놈이 그 *복잡한 로직*을 실행시키고 파일 시스템을 다루는거지? 그게 없다면 말이 안 되잖아?'**

수많은 구글링 끝에 단순한 입문용 문서들을 헤치고 꽤 유익한 정보들을 발견 했는데...! [^1]

결론적으로 말하자면, 흔히들 Node.js는 싱글스레드라 말하지만 **엄밀히 따지면 Node.js 자체는 싱글스레드로만 돌아가는 것은 아닌거 같다.**<br>

디테일한 내용에 앞서, '노드가 제공하는 기본적인 API들은 사실 V8엔진과 **libuv** 라는 두가지 트랙으로 작업을 수행한다.' 라는 ~~나한테만~~ 새로운 사실을 공유하고 싶다.

- 노드에서 CPU bound의 작업 대부분(우리가 작성하는 '일반적인' 자바스크립트 코드)은 V8엔진에 의해 해석되어 동기적으로 실행되어진다.
- 일반적으로 비동기적으로 작동한다고 알고있는 함수들(IO Bound 로 실행되면서 명시적으로 동기적인 기능을 하는 함수들을 제외하면 대부분)이 수행하는 작업은 **libuv**에 던져진다.

---

## libuv! 잡았다 요놈!

<br>
그렇다면 libuv가 뭔지 알아봐야겠지.

[libuv](https://github.com/libuv/libuv/tree/v1.x/src/unix)는 OS 시스템의 비동기 처리를 한단계 추상화하여 cross-platform 비동기를 구현한 라이브러리로 노드의 코어중 하나이다.<br>
우리가 노드의 구동방식에 대해 공부하면 항상 나오는 EventLoop도 여기에 구현되어 있다.

우리가 사전에 정의된 노드의 비동기 API를 호출하면, **libuv**는 block 상태에 있던 이벤트 루프를 실행시키는데, 이벤트 루프는 작업의 종류에 따라서

- **OS커널이 해당 작업에 대한 비동기 API를 제공하면** -> 커널의 비동기 API(Window-IOCP, linux-AIO) 실행을 통해서 작업수행
- **OS커널 마저 비동기로 처리할 방법을 제공하지 않으면**(대표적으로 파일 시스템) -> worker thread를 할당하여 작업을 수행(worker thread는 디폴트 4개 존재)

이렇게 분기하여 수행하도록 uv_io라는 친구에게 작업을 위임한다.<br>
할일을 위임 받은 uv_io는 앞서 말한 것처럼, 커널의 비동기API 지원 여부에 따라 커널에 작업을 재위임 하거나, 우리가 일반적으로 생각하는 순차적인 blocking 로직을 워커 쓰레드를 이용하여 실행시킨다.

**결국! 노드는 OS커널에서 지원하지 않는 비동기 작업은 멀티 스레드를 사용한다!(유저쓰레드)**

이후의 과정은, 우리가 이벤트 루프에 대해 가볍게 공부했던 내용대로, uv_io가 작업이 끝나면 작업 종류에 따라 콜백을 이벤트 큐에 등록하고 여전히 열심히 돌고있는 무한 루프에 의해 실행되기를 기대한다.

---

## 그럼 우리는 왜 노드가 싱글스레드라고 알고 있지?

사실 이건 노드가 의도한 바 인것 같다. 비동기작업을 추상화 하고 이벤트루프라는 인터페이스만 내놓는게 libuv의 목적이니.

널리 알려진것 처럼, 결론적으로 노드에 작성한 자바스크립트 코드는 개발자의 입장에서 비동기IO/싱글스레드로 돈다. 이는 이벤트루프가 노드 런타임에 딱 하나만 싱글스레드로 구동되기 때문이다.

하지만 이제는 비교적 자신있게 이야기 할 수 있을거 같다. **노드에서 돌아가는 코드는 싱글스레드처럼 동작하지만, 노드 런타임 그 자체의 구현은 여러개의 워커쓰레드를 사용한다!**

다음에 시간나면 libuv도 더 자세히 뜯어봐야지...

---

## 이만하면 애플리케이션 레벨 개발자 로서 납등가능, 근데 꿀팁좀

사실 로우레벨을 공부하는것을 좋아하는 편이라서 더 파보고 싶지만, 생산성을 생각했을 때 이정도가 애플리케이션 레벨 개발자로서 스스로 납득이 가는 정도인 것 같다.~~또 자기합리화~~

여담으로, 이에반해 자바로 짜여진 전통적인 서버 애플리케이션은 요청당 하나의 스레드를 만든다. 만들어진 스레드의 생에주기는 애플리케이션 레벨에서 개발자가 제어해야한다. 반면 노드는 모든 요청을 단일 스레드로 받기 때문에,
애플리케이션 레벨에서는 스레드 자원을 신경 쓸 필요 없이 동시성을 편하게 구현할 수 있다는 장점이 있다.

그러한 이유에서 노드의 단점역시 명확한데, 모두가 알고있듯이, 한 요청에서 cpu를 많이 사용하는 작업을 한다면(극단적 예, while(true) 무한루프) 이벤트루프가 이 작업을 처리하느라 이후 들어오는 요청에 대해 대응할 여유가 없으므로
요청의 응답이 느려지거나 응답하지 않을 수 있다(심지어 이 경우는 로깅이나 트레이싱도 힘들거같다... <u>이것도 재밌겠군!<u>).

주의해야할 한 가지는 노드서버를 작성할 때 스레드 자원을 신경쓰지 않는다는 말이 동시성 코드를 사용함에 주의가 필요하지 않다는 말은 아니다. **여러개의 요청이 공유하는 리소스에 쓰기접근할 때 특히 주의를 기울여야한다.**

모든 요청이 해당 리소스에 대해서 읽기만 수행하면 괜찮지만, Dirty Read, Unrepeatable Read 등 공유되는 리소스에 대한 어떤 문제든지 나타날 가능성이 있으므로 주의해야한다.
<sub>[관련된 나의 부끄러운 실수](/projects/work/여러_요청이_한_리소스에_동시_접근_할_때)</sub>

---

[^1]: [https://ocsusu.tistory.com/20](https://ocsusu.tistory.com/20), [https://ocsusu.tistory.com/20](https://sjh836.tistory.com/149)
